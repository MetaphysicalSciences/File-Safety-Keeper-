<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ultra Beefy Custom Encryptor</title>
<style>
  body {
    background: #121212;
    color: #eee;
    font-family: monospace, monospace;
    padding: 1rem 2rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    max-width: 480px;
    margin: auto;
  }
  input[type=file], input[type=password], input[type=number] {
    width: 100%;
    padding: 0.6rem;
    margin: 0.5rem 0;
    font-size: 1rem;
    background: #222;
    color: #eee;
    border: none;
    border-radius: 4px;
  }
  button {
    width: 100%;
    padding: 0.8rem;
    margin: 0.5rem 0;
    font-size: 1.1rem;
    background: #0088ff;
    border: none;
    border-radius: 5px;
    color: white;
    cursor: pointer;
    user-select: none;
  }
  button:disabled {
    background: #555;
    cursor: default;
  }
  #passwordDisplay {
    background: #222;
    padding: 0.6rem;
    margin: 0.5rem 0 1rem 0;
    font-weight: bold;
    word-break: break-all;
    user-select: text;
  }
  progress {
    width: 100%;
    height: 1.2rem;
    margin: 0.5rem 0 1rem 0;
    border-radius: 5px;
    background: #222;
  }
  a {
    margin-top: 0.6rem;
    color: #4af;
    word-break: break-word;
  }
  #dropAreaEnc, #dropAreaDec {
    width: 100%;
    border: 3px dashed #555;
    padding: 1rem;
    margin: 0.5rem 0;
    text-align: center;
    color: #777;
    user-select: none;
  }
  #dropAreaEnc.dragover, #dropAreaDec.dragover {
    border-color: #08f;
    color: #0af;
  }
  #strengthMeter {
    height: 8px;
    width: 100%;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
    margin-top: -0.7rem;
    margin-bottom: 1rem;
  }
  #strengthFill {
    height: 100%;
    background: #f00;
    width: 0%;
    transition: width 0.3s ease, background 0.3s ease;
  }
</style>
</head>
<body>

<h1>Giga Encryptor</h1>

<h2>Encrypt</h2>

<div id="dropAreaEnc">Drag & Drop files here or use file selector</div>
<input type="file" id="fileInput" multiple />
<input type="number" id="layerCount" min="1" max="3000" value="100" placeholder="Layers (1-3000)" />
<input type="number" id="decoyCount" min="1" max="3000" value="20" placeholder="Decoys (1-3000)" />
<input type="password" id="encryptPassword" placeholder="Enter or generate password" autocomplete="new-password" />
<div id="strengthMeter"><div id="strengthFill"></div></div>
<button id="genPassBtn">Generate 50-Char Strong Password</button>
<div id="passwordDisplay"></div>
<button id="encryptBtn">Encrypt Files (Custom Layers)</button>
<progress id="encryptProgress" max="100" value="0" style="display:none;"></progress>
<div id="encryptOutput"></div>

<hr />

<h2>Decrypt</h2>

<div id="dropAreaDec">Drag & Drop .SuperEncrypted files here or use file selector</div>
<input type="file" id="decryptFileInput" multiple />
<input type="password" id="decryptPassword" placeholder="Enter password to decrypt" autocomplete="off" />
<input type="number" id="layerCountDec" min="1" max="3000" value="100" placeholder="Layers used in encryption" />
<button id="decryptBtn">Decrypt Files</button>
<progress id="decryptProgress" max="100" value="0" style="display:none;"></progress>
<div id="decryptOutput"></div>

<script>
const SALT_LENGTH = 32;
const IV_LENGTH = 12;

function getRandomChar() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+[]{}|;:,.<>?~';
  return chars.charAt(Math.floor(Math.random() * chars.length));
}
function generatePassword(length = 50) {
  let pass = '';
  while (pass.length < length) pass += getRandomChar();
  return pass;
}
function encodeUTF8(str) { return new TextEncoder().encode(str); }
function decodeUTF8(buf) { return new TextDecoder().decode(buf); }
async function getRandomBytes(len) {
  const arr = new Uint8Array(len);
  crypto.getRandomValues(arr);
  return arr;
}
async function deriveKey(password, salt) {
  const pwUtf8 = encodeUTF8(password);
  const baseKey = await crypto.subtle.importKey('raw', pwUtf8, 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 1000000, hash: 'SHA-256' },
    baseKey,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
}
async function encryptLayer(buffer, password) {
  const salt = await getRandomBytes(SALT_LENGTH);
  const iv = await getRandomBytes(IV_LENGTH);
  const key = await deriveKey(password, salt);
  const encrypted = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, buffer);
  const combined = new Uint8Array(SALT_LENGTH + IV_LENGTH + encrypted.byteLength);
  combined.set(salt, 0);
  combined.set(iv, SALT_LENGTH);
  combined.set(new Uint8Array(encrypted), SALT_LENGTH + IV_LENGTH);
  return combined.buffer;
}
async function decryptLayer(buffer, password) {
  const data = new Uint8Array(buffer);
  const salt = data.slice(0, SALT_LENGTH);
  const iv = data.slice(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);
  const ciphertext = data.slice(SALT_LENGTH + IV_LENGTH);
  const key = await deriveKey(password, salt.buffer);
  const decrypted = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ciphertext.buffer);
  return decrypted;
}
async function generateDecoys(count, minSize, maxSize) {
  const decoys = [];
  for(let i=0; i<count; i++) {
    const size = minSize + Math.floor(Math.random()*(maxSize-minSize));
    const arr = await getRandomBytes(size);
    decoys.push(arr);
  }
  return decoys;
}
async function addFakeHeadersAndDecoys(buffer, decoyCount) {
  const pngHeader = new Uint8Array([0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A]);
  const pdfHeader = new TextEncoder().encode('%PDF-1.7\n%    \n');
  const zipHeader = new Uint8Array([0x50,0x4B,0x03,0x04]);
  const fakeHeaders = [pngHeader, pdfHeader, zipHeader];
  const decoys = await generateDecoys(decoyCount, 128, 512);
  let totalSize = buffer.byteLength;
  fakeHeaders.forEach(h => totalSize += h.byteLength);
  decoys.forEach(d => totalSize += d.byteLength);
  const combined = new Uint8Array(totalSize);
  let offset = 0;
  for(const header of fakeHeaders) {
    combined.set(header, offset);
    offset += header.byteLength;
  }
  combined.set(new Uint8Array(buffer), offset);
  offset += buffer.byteLength;
  for(const decoy of decoys) {
    combined.set(decoy, offset);
    offset += decoy.byteLength;
  }
  return combined.buffer;
}
function concatArrayBuffers(buffers) {
  let totalLength = 0;
  for (const b of buffers) totalLength += b.byteLength;
  const temp = new Uint8Array(totalLength);
  let offset = 0;
  for (const b of buffers) {
    temp.set(new Uint8Array(b), offset);
    offset += b.byteLength;
  }
  return temp.buffer;
}
function splitMultiFiles(buffer) {
  let offset = 0;
  const result = [];
  while(offset < buffer.byteLength) {
    if(offset + 4 > buffer.byteLength) break;
    const nameLenView = new DataView(buffer, offset, 4);
    const nameLen = nameLenView.getUint32(0, true);
    offset += 4;
    if(offset + nameLen > buffer.byteLength) break;
    const nameBytes = new Uint8Array(buffer, offset, nameLen);
    offset += nameLen;
    if(offset + 4 > buffer.byteLength) break;
    const dataLenView = new DataView(buffer, offset, 4);
    const dataLen = dataLenView.getUint32(0, true);
    offset += 4;
    if(offset + dataLen > buffer.byteLength) break;
    const data = buffer.slice(offset, offset + dataLen);
    offset += dataLen;
    const name = decodeUTF8(nameBytes);
    result.push({name, data});
  }
  return result;
}
function createMultiFileBuffer(files) {
  const chunks = [];
  for(const f of files) {
    const nameEncoded = encodeUTF8(f.name);
    const nameLenBuf = new ArrayBuffer(4);
    new DataView(nameLenBuf).setUint32(0, nameEncoded.byteLength, true);
    const dataLenBuf = new ArrayBuffer(4);
    new DataView(dataLenBuf).setUint32(0, f.data.byteLength, true);
    chunks.push(nameLenBuf, nameEncoded.buffer, dataLenBuf, f.data);
  }
  return concatArrayBuffers(chunks);
}
function stripFakeHeadersAndDecoys(buffer) {
  // Remove known headers if present at start
  let data = new Uint8Array(buffer);
  const headers = [
    new Uint8Array([0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A]), // PNG
    new TextEncoder().encode('%PDF-1.7\n%    \n'),
    new Uint8Array([0x50,0x4B,0x03,0x04]) // ZIP
  ];
  for(const h of headers) {
    let found = true;
    if(data.length >= h.length) {
      for(let i=0; i<h.length; i++) if(data[i] !== h[i]) found = false;
      if(found) data = data.slice(h.length);
    }
  }
  // Remove trailing decoys by heuristics: remove trailing random blocks smaller than 600 bytes
  while(data.length > 512) {
    let decoyCandidateLen = 512;
    let segment = data.slice(data.length - decoyCandidateLen);
    let entropy = 0;
    let freq = {};
    for(const b of segment) freq[b] = (freq[b]||0)+1;
    for(const k in freq) {
      let p = freq[k]/segment.length;
      entropy -= p * Math.log2(p);
    }
    if(entropy > 7.5) data = data.slice(0, data.length - decoyCandidateLen);
    else break;
  }
  return data.buffer;
}

function checkPasswordStrength(pw) {
  let score = 0;
  if(pw.length >= 12) score += 25;
  if(/[a-z]/.test(pw)) score += 15;
  if(/[A-Z]/.test(pw)) score += 20;
  if(/[0-9]/.test(pw)) score += 20;
  if(/[^a-zA-Z0-9]/.test(pw)) score += 20;
  if(pw.length >= 24) score += 10;
  return Math.min(score, 100);
}

const fileInput = document.getElementById('fileInput');
const encryptPassword = document.getElementById('encryptPassword');
const genPassBtn = document.getElementById('genPassBtn');
const encryptBtn = document.getElementById('encryptBtn');
const encryptProgress = document.getElementById('encryptProgress');
const encryptOutput = document.getElementById('encryptOutput');
const passwordDisplay = document.getElementById('passwordDisplay');
const layerCountInput = document.getElementById('layerCount');
const decoyCountInput = document.getElementById('decoyCount');
const dropAreaEnc = document.getElementById('dropAreaEnc');

const decryptFileInput = document.getElementById('decryptFileInput');
const decryptPassword = document.getElementById('decryptPassword');
const decryptBtn = document.getElementById('decryptBtn');
const decryptProgress = document.getElementById('decryptProgress');
const decryptOutput = document.getElementById('decryptOutput');
const layerCountDecInput = document.getElementById('layerCountDec');
const dropAreaDec = document.getElementById('dropAreaDec');

const strengthFill = document.getElementById('strengthFill');

encryptPassword.addEventListener('input', () => {
  const score = checkPasswordStrength(encryptPassword.value);
  strengthFill.style.width = score + '%';
  strengthFill.style.background = score < 40 ? '#f33' : score < 70 ? '#fa3' : '#3f3';
});

genPassBtn.onclick = () => {
  const p = generatePassword();
  encryptPassword.value = p;
  passwordDisplay.textContent = p;
  const score = checkPasswordStrength(p);
  strengthFill.style.width = score + '%';
  strengthFill.style.background = '#3f3';
};
encryptBtn.onclick = async () => {
  if ((!fileInput.files.length && dropAreaEnc.files.length === 0) && dropAreaEnc._files?.length !== undefined && dropAreaEnc._files.length === 0) {
    alert('Select or drop files');
    return;
  }
  if (!encryptPassword.value) {
    alert('Enter or generate password');
    return;
  }
  let layers = Number(layerCountInput.value);
  let decoys = Number(decoyCountInput.value);
  if (!layers || layers < 1) layers = 100;
  else if (layers > 3000) layers = 3000;
  if (!decoys || decoys < 1) decoys = 20;
  else if (decoys > 3000) decoys = 3000;
  encryptBtn.disabled = true; genPassBtn.disabled = true;
  encryptProgress.style.display = 'block';
  encryptProgress.value = 0;
  encryptOutput.innerHTML = '';
  try {
    let files = fileInput.files.length ? fileInput.files : dropAreaEnc._files;
    let toEncrypt = [];
    for(const f of files) {
      encryptOutput.appendChild(document.createTextNode(`Loading: ${f.name}`));
      encryptOutput.appendChild(document.createElement('br'));
      const buff = await f.arrayBuffer();
      toEncrypt.push({name: f.name, data: buff});
    }
    let combinedBuffer = createMultiFileBuffer(toEncrypt);
    combinedBuffer = await addFakeHeadersAndDecoys(combinedBuffer, decoys);
    let data = combinedBuffer;
    for(let i=0; i<layers; i++) {
      data = await encryptLayer(data, encryptPassword.value);
      encryptProgress.value = (i+1)/layers*100;
      await new Promise(r=>setTimeout(r,1));
    }
    saveFile(data, 'Files.SuperEncrypted');
    encryptOutput.appendChild(document.createTextNode(`Encrypted file saved: Files.SuperEncrypted`));
  } catch(e) {
    alert('Encryption failed: ' + e.message);
  }
  encryptBtn.disabled = false; genPassBtn.disabled = false;
  encryptProgress.style.display = 'none';
};

decryptBtn.onclick = async () => {
  if ((!decryptFileInput.files.length && dropAreaDec._files?.length === 0)) {
    alert('Select or drop files');
    return;
  }
  if (!decryptPassword.value) {
    alert('Enter password');
    return;
  }
  let layers = Number(layerCountDecInput.value);
  if (!layers || layers < 1) layers = 100;
  else if (layers > 3000) layers = 3000;
  decryptBtn.disabled = true;
  decryptProgress.style.display = 'block';
  decryptProgress.value = 0;
  decryptOutput.innerHTML = '';
  try {
    let files = decryptFileInput.files.length ? decryptFileInput.files : dropAreaDec._files;
    for(const f of files) {
      decryptOutput.appendChild(document.createTextNode(`Decrypting: ${f.name}`));
      decryptOutput.appendChild(document.createElement('br'));
      let buffer = await f.arrayBuffer();
      for(let i=0; i<layers; i++) {
        buffer = await decryptLayer(buffer, decryptPassword.value);
        decryptProgress.value = (i+1)/layers*100;
        await new Promise(r=>setTimeout(r,1));
      }
      buffer = stripFakeHeadersAndDecoys(buffer);
      const parts = splitMultiFiles(buffer);
      if(parts.length === 0) {
        saveFile(buffer, f.name.replace(/\.SuperEncrypted$/, '') || 'decrypted.file');
        decryptOutput.appendChild(document.createTextNode(`Decrypted saved: ${f.name.replace(/\.SuperEncrypted$/, '') || 'decrypted.file'}`));
      } else {
        for(const p of parts) {
          saveFile(p.data, p.name);
          decryptOutput.appendChild(document.createTextNode(`Decrypted saved: ${p.name}`));
          decryptOutput.appendChild(document.createElement('br'));
        }
      }
    }
  } catch(e) {
    alert('Decryption failed: ' + e.message);
  }
  decryptBtn.disabled = false;
  decryptProgress.style.display = 'none';
};

function saveFile(buffer, name) {
  const blob = new Blob([buffer]);
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function preventDefaults(e) {
  e.preventDefault();
  e.stopPropagation();
}

function highlight(e) {
  e.currentTarget.classList.add('dragover');
}

function unhighlight(e) {
  e.currentTarget.classList.remove('dragover');
}

dropAreaEnc.addEventListener('dragenter', preventDefaults, false);
dropAreaEnc.addEventListener('dragover', preventDefaults, false);
dropAreaEnc.addEventListener('dragleave', preventDefaults, false);
dropAreaEnc.addEventListener('drop', preventDefaults, false);
dropAreaEnc.addEventListener('dragenter', highlight, false);
dropAreaEnc.addEventListener('dragover', highlight, false);
dropAreaEnc.addEventListener('dragleave', unhighlight, false);
dropAreaEnc.addEventListener('drop', unhighlight, false);
dropAreaEnc.addEventListener('drop', e => {
  dropAreaEnc._files = e.dataTransfer.files;
  dropAreaEnc.textContent = `${dropAreaEnc._files.length} file(s) ready for encryption`;
  fileInput.value = ''; // clear input to avoid confusion
});

dropAreaDec.addEventListener('dragenter', preventDefaults, false);
dropAreaDec.addEventListener('dragover', preventDefaults, false);
dropAreaDec.addEventListener('dragleave', preventDefaults, false);
dropAreaDec.addEventListener('drop', preventDefaults, false);
dropAreaDec.addEventListener('dragenter', highlight, false);
dropAreaDec.addEventListener('dragover', highlight, false);
dropAreaDec.addEventListener('dragleave', unhighlight, false);
dropAreaDec.addEventListener('drop', unhighlight, false);
dropAreaDec.addEventListener('drop', e => {
  dropAreaDec._files = e.dataTransfer.files;
  dropAreaDec.textContent = `${dropAreaDec._files.length} file(s) ready for decryption`;
  decryptFileInput.value = '';
});
</script>

</body>
</html>
