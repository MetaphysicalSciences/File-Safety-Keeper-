<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Giga Encryptor</title>
<style>
  body {
    background: #121212;
    color: #eee;
    font-family: monospace, monospace;
    padding: 1rem 2rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    max-width: 600px;
    margin: auto;
  }
  input[type=file], input[type=password], input[type=number] {
    width: 100%;
    padding: 0.6rem;
    margin: 0.5rem 0;
    font-size: 1rem;
    background: #222;
    color: #eee;
    border: none;
    border-radius: 4px;
  }
  button {
    width: 100%;
    padding: 0.8rem;
    margin: 0.5rem 0;
    font-size: 1.1rem;
    background: #0088ff;
    border: none;
    border-radius: 5px;
    color: white;
    cursor: pointer;
    user-select: none;
  }
  button:disabled {
    background: #555;
    cursor: default;
  }
  #passwordDisplay {
    background: #222;
    padding: 0.6rem;
    margin: 0.5rem 0 1rem 0;
    font-weight: bold;
    word-break: break-all;
    user-select: text;
  }
  progress {
    width: 100%;
    height: 1.2rem;
    margin: 0.5rem 0 1rem 0;
    border-radius: 5px;
    background: #222;
  }
  a {
    margin-top: 0.6rem;
    color: #4af;
    word-break: break-word;
  }
  #dropZone {
    border: 2px dashed #4af;
    padding: 1rem;
    width: 100%;
    text-align: center;
    color: #4af;
    margin: 1rem 0;
    user-select: none;
  }
  #dropZone.dragover {
    background-color: #004080;
  }
  #strengthBar {
    height: 1rem;
    width: 100%;
    background: #333;
    border-radius: 5px;
    overflow: hidden;
    margin-bottom: 0.5rem;
  }
  #strengthFill {
    height: 100%;
    width: 0%;
    background: limegreen;
    transition: width 0.3s ease;
  }
</style>
</head>
<body>

<h1>Its Beefy And Great At Its Job</h1>

<h2>Config</h2>
<label>Layers (1-3000)</label>
<input type="number" id="layersInput" min="1" max="3000" value="100" />
<label>Decoys (1-3000)</label>
<input type="number" id="decoysInput" min="1" max="3000" value="20" />

<h2>Encrypt</h2>
<div id="dropZone">Drag & Drop Files Here or Click to Select</div>
<input type="file" id="fileInput" multiple style="display:none" />
<input type="password" id="encryptPassword" placeholder="Enter or generate password" autocomplete="new-password" />
<div id="strengthBar"><div id="strengthFill"></div></div>
<button id="genPassBtn">Generate 50-Char Strong Password</button>
<div id="passwordDisplay"></div>
<button id="encryptBtn">Encrypt Files (Configurable Layers)</button>
<progress id="encryptProgress" max="100" value="0" style="display:none;"></progress>
<div id="encryptOutput"></div>

<hr />

<h2>Decrypt</h2>
<input type="file" id="decryptFileInput" multiple />
<input type="password" id="decryptPassword" placeholder="Enter password to decrypt" autocomplete="off" />
<button id="decryptBtn">Decrypt Files</button>
<progress id="decryptProgress" max="100" value="0" style="display:none;"></progress>
<div id="decryptOutput"></div>

<script>
const SALT_LENGTH = 32;
const IV_LENGTH = 12;

function getRandomChar() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+[]{}|;:,.<>?~';
  return chars.charAt(Math.floor(Math.random() * chars.length));
}
function generatePassword(length = 50) {
  let pass = '';
  while (pass.length < length) pass += getRandomChar();
  return pass;
}
function encodeUTF8(str) { return new TextEncoder().encode(str); }
function decodeUTF8(buf) { return new TextDecoder().decode(buf); }
async function getRandomBytes(len) {
  const arr = new Uint8Array(len);
  crypto.getRandomValues(arr);
  return arr;
}
async function deriveKey(password, salt) {
  const pwUtf8 = encodeUTF8(password);
  const baseKey = await crypto.subtle.importKey('raw', pwUtf8, 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 1000000, hash: 'SHA-256' },
    baseKey,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
}
async function encryptLayer(buffer, password) {
  const salt = await getRandomBytes(SALT_LENGTH);
  const iv = await getRandomBytes(IV_LENGTH);
  const key = await deriveKey(password, salt);
  const encrypted = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, buffer);
  const combined = new Uint8Array(SALT_LENGTH + IV_LENGTH + encrypted.byteLength);
  combined.set(salt, 0);
  combined.set(iv, SALT_LENGTH);
  combined.set(new Uint8Array(encrypted), SALT_LENGTH + IV_LENGTH);
  return combined.buffer;
}
async function decryptLayer(buffer, password) {
  const data = new Uint8Array(buffer);
  const salt = data.slice(0, SALT_LENGTH);
  const iv = data.slice(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);
  const ciphertext = data.slice(SALT_LENGTH + IV_LENGTH);
  const key = await deriveKey(password, salt.buffer);
  return await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ciphertext.buffer);
}
function concatBuffers(buffers) {
  let totalLength = buffers.reduce((acc,b)=>acc+b.byteLength,0);
  let tmp = new Uint8Array(totalLength);
  let offset=0;
  for(let b of buffers) {
    tmp.set(new Uint8Array(b), offset);
    offset+=b.byteLength;
  }
  return tmp.buffer;
}
function splitBuffers(buffer) {
  const view = new Uint8Array(buffer);
  let files = [];
  let offset = 0;
  while(offset < view.length) {
    if(offset+4 > view.length) break;
    let nameLen = view[offset] << 24 | view[offset+1] << 16 | view[offset+2] << 8 | view[offset+3];
    offset +=4;
    if(offset + nameLen > view.length) break;
    let nameBuf = view.slice(offset, offset+nameLen);
    let filename = decodeUTF8(nameBuf);
    offset += nameLen;
    if(offset + 8 > view.length) break;
    let fileLen = Number(
      (BigInt(view[offset]) << 56n) | (BigInt(view[offset+1]) << 48n) | (BigInt(view[offset+2]) << 40n) | (BigInt(view[offset+3]) << 32n) |
      (BigInt(view[offset+4]) << 24n) | (BigInt(view[offset+5]) << 16n) | (BigInt(view[offset+6]) << 8n) | BigInt(view[offset+7])
    );
    offset += 8;
    if(offset + fileLen > view.length) break;
    let fileData = view.slice(offset, offset+fileLen);
    offset += fileLen;
    files.push({filename, fileData});
  }
  return files;
}
function packFiles(files) {
  let buffers = [];
  for(let f of files) {
    let nameBuf = encodeUTF8(f.name);
    let nameLenBuf = new Uint8Array(4);
    nameLenBuf[0] = (nameBuf.length >> 24) & 0xFF;
    nameLenBuf[1] = (nameBuf.length >> 16) & 0xFF;
    nameLenBuf[2] = (nameBuf.length >> 8) & 0xFF;
    nameLenBuf[3] = (nameBuf.length) & 0xFF;
    let fileLenBuf = new Uint8Array(8);
    let lenBig = BigInt(f.data.byteLength);
    for(let i=7;i>=0;i--) {
      fileLenBuf[i] = Number(lenBig & 0xFFn);
      lenBig >>= 8n;
    }
    buffers.push(nameLenBuf.buffer, nameBuf.buffer, fileLenBuf.buffer, f.data);
  }
  return concatBuffers(buffers);
}
async function generateDecoys(count, minSize, maxSize) {
  let decoys = [];
  for(let i=0;i<count;i++) {
    let size = minSize + Math.floor(Math.random()*(maxSize-minSize));
    decoys.push(await getRandomBytes(size));
  }
  return decoys;
}
async function addFakeHeadersAndDecoys(buffer, decoys) {
  const pngHeader = new Uint8Array([0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A]);
  const pdfHeader = encodeUTF8('%PDF-1.7\n%����\n');
  const zipHeader = new Uint8Array([0x50,0x4B,0x03,0x04]);
  const fakeHeaders = [pngHeader, pdfHeader, zipHeader];
  let totalSize = buffer.byteLength;
  fakeHeaders.forEach(h => totalSize += h.byteLength);
  decoys.forEach(d => totalSize += d.byteLength);
  const combined = new Uint8Array(totalSize);
  let offset=0;
  for(const h of fakeHeaders) {
    combined.set(h, offset);
    offset+=h.byteLength;
  }
  combined.set(new Uint8Array(buffer), offset);
  offset += buffer.byteLength;
  for(const d of decoys) {
    combined.set(d, offset);
    offset+=d.byteLength;
  }
  return combined.buffer;
}
function stripFakeHeadersAndDecoys(buffer) {
  const pngHeader = [0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A];
  const pdfHeaderStr = '%PDF-1.7\n%����\n';
  const zipHeader = [0x50,0x4B,0x03,0x04];
  let view = new Uint8Array(buffer);
  let start = 0;
  // Strip PNG header
  if(view.length > pngHeader.length) {
    let found = true;
    for(let i=0;i<pngHeader.length;i++) if(view[i]!==pngHeader[i]) found=false;
    if(found) start = pngHeader.length;
  }
  // Or PDF header
  else if(view.length > pdfHeaderStr.length) {
    let str = decodeUTF8(view.slice(0,pdfHeaderStr.length));
    if(str===pdfHeaderStr) start = pdfHeaderStr.length;
  }
  // Or ZIP header
  else if(view.length > zipHeader.length) {
    let found = true;
    for(let i=0;i<zipHeader.length;i++) if(view[i]!==zipHeader[i]) found=false;
    if(found) start = zipHeader.length;
  }
  let cutoff = view.length;
  for(let i=view.length-1; i>start+100; i--) {
    if(view[i]===0) cutoff = i;
  }
  if(cutoff > start) return view.slice(start, cutoff).buffer;
  return view.slice(start).buffer;
}
function updateStrengthMeter(p) {
  const s = document.getElementById('strengthFill');
  let score=0;
  if(p.length >= 12) score+=1;
  if(/[a-z]/.test(p)) score+=1;
  if(/[A-Z]/.test(p)) score+=1;
  if(/\d/.test(p)) score+=1;
  if(/[!@#$%^&*()\-_=+\[\]{}|;:,.<>?~]/.test(p)) score+=1;
  if(p.length >= 20) score+=1;
  s.style.width = (score/6*100) + '%';
  if(score<3) s.style.background='red';
  else if(score<5) s.style.background='orange';
  else s.style.background='limegreen';
}
async function encryptMultiLayer(buffer, password, layers, decoys, onProgress) {
  let data = await addFakeHeadersAndDecoys(buffer, decoys);
  for(let i=0;i<layers;i++) {
    data = await encryptLayer(data, password);
    if(onProgress) onProgress(i+1);
    await new Promise(r=>setTimeout(r,1));
  }
  return data;
}
async function decryptMultiLayer(buffer, password, layers, onProgress) {
  let data = buffer;
  for(let i=0;i<layers;i++) {
    data = await decryptLayer(data, password);
    if(onProgress) onProgress(i+1);
    await new Promise(r=>setTimeout(r,1));
  }
  data = stripFakeHeadersAndDecoys(data);
  return data;
}

const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const encryptPassword = document.getElementById('encryptPassword');
const genPassBtn = document.getElementById('genPassBtn');
const encryptBtn = document.getElementById('encryptBtn');
const encryptProgress = document.getElementById('encryptProgress');
const encryptOutput = document.getElementById('encryptOutput');
const passwordDisplay = document.getElementById('passwordDisplay');
const layersInput = document.getElementById('layersInput');
const decoysInput = document.getElementById('decoysInput');

const decryptFileInput = document.getElementById('decryptFileInput');
const decryptPassword = document.getElementById('decryptPassword');
const decryptBtn = document.getElementById('decryptBtn');
const decryptProgress = document.getElementById('decryptProgress');
const decryptOutput = document.getElementById('decryptOutput');

const strengthInput = encryptPassword;
strengthInput.addEventListener('input', e => updateStrengthMeter(e.target.value));

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => {
  e.preventDefault();
  dropZone.classList.add('dragover');
});
dropZone.addEventListener('dragleave', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
});
dropZone.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  const dtFiles = e.dataTransfer.files;
  if(dtFiles.length > 0) {
    fileInput.files = dtFiles;
    encryptOutput.innerHTML = `Selected ${dtFiles.length} files for encryption.`;
  }
});

genPassBtn.onclick = () => {
  const p = generatePassword();
  encryptPassword.value = p;
  passwordDisplay.textContent = p;
  updateStrengthMeter(p);
};

encryptBtn.onclick = async () => {
  if(fileInput.files.length === 0) {
    alert('Select files to encrypt.');
    return;
  }
  if(!encryptPassword.value) {
    alert('Enter or generate password.');
    return;
  }
  let layers = Number(layersInput.value);
  if(isNaN(layers) || layers < 1 || layers > 3000) {
    alert('Layers must be between 1 and 3000.');
    return;
  }
  let decoysCount = Number(decoysInput.value);
  if(isNaN(decoysCount) || decoysCount < 1 || decoysCount > 3000) {
    alert('Decoys must be between 1 and 3000.');
    return;
  }
  encryptBtn.disabled = true; genPassBtn.disabled = true;
  encryptProgress.style.display = 'block';
  encryptProgress.value = 0;
  encryptOutput.innerHTML = '';

  try {
    let files = [];
    for(let f of fileInput.files) {
      encryptOutput.appendChild(document.createTextNode(`Reading ${f.name}...`));
      encryptOutput.appendChild(document.createElement('br'));
      let buffer = await f.arrayBuffer();
      files.push({name:f.name, data:buffer});
    }
    let packed = packFiles(files);
    let decoys = await generateDecoys(decoysCount, 128, 512);
    let encrypted = await encryptMultiLayer(packed, encryptPassword.value, layers, decoys, v => {
      encryptProgress.value = (v/layers)*100;
    });
    saveFile(encrypted, 'MultiFiles.SuperEncrypted');
    encryptOutput.appendChild(document.createTextNode(`Encryption complete. Saved as MultiFiles.SuperEncrypted`));
  } catch(e) {
    alert('Encryption failed: ' + e.message);
  }
  encryptBtn.disabled = false; genPassBtn.disabled = false;
  encryptProgress.style.display = 'none';
};

decryptBtn.onclick = async () => {
  if(decryptFileInput.files.length === 0) {
    alert('Select encrypted files to decrypt.');
    return;
  }
  if(!decryptPassword.value) {
    alert('Enter password.');
    return;
  }
  let layers = Number(layersInput.value);
  if(isNaN(layers) || layers < 1 || layers > 3000) {
    alert('Layers must be between 1 and 3000.');
    return;
  }
  decryptBtn.disabled = true;
  decryptProgress.style.display = 'block';
  decryptProgress.value = 0;
  decryptOutput.innerHTML = '';

  try {
    for(let f of decryptFileInput.files) {
      decryptOutput.appendChild(document.createTextNode(`Decrypting ${f.name}...`));
      decryptOutput.appendChild(document.createElement('br'));
      let buffer = await f.arrayBuffer();
      let decrypted = await decryptMultiLayer(buffer, decryptPassword.value, layers, v => {
        decryptProgress.value = (v/layers)*100;
      });
      let files = splitBuffers(decrypted);
      if(files.length === 0) {
        saveFile(decrypted, f.name.replace(/\.SuperEncrypted$/, '') || 'decrypted.file');
        decryptOutput.appendChild(document.createTextNode(`Decrypted saved as raw file.`));
      } else {
        for(let file of files) {
          saveFile(file.fileData.buffer, file.filename);
          decryptOutput.appendChild(document.createTextNode(`Decrypted saved: ${file.filename}`));
          decryptOutput.appendChild(document.createElement('br'));
        }
      }
    }
  } catch(e) {
    alert('Decryption failed: ' + e.message);
  }
  decryptBtn.disabled = false;
  decryptProgress.style.display = 'none';
};
</script>

</body>
</html>
