<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Giga Encryptor</title>
<style>
  body {
    background: #121212;
    color: #eee;
    font-family: monospace, monospace;
    padding: 1rem 2rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    max-width: 480px;
    margin: auto;
  }
  input[type=file], input[type=password] {
    width: 100%;
    padding: 0.6rem;
    margin: 0.5rem 0;
    font-size: 1rem;
    background: #222;
    color: #eee;
    border: none;
    border-radius: 4px;
  }
  button {
    width: 100%;
    padding: 0.8rem;
    margin: 0.5rem 0;
    font-size: 1.1rem;
    background: #0088ff;
    border: none;
    border-radius: 5px;
    color: white;
    cursor: pointer;
    user-select: none;
  }
  button:disabled {
    background: #555;
    cursor: default;
  }
  #passwordDisplay {
    background: #222;
    padding: 0.6rem;
    margin: 0.5rem 0 1rem 0;
    font-weight: bold;
    word-break: break-all;
    user-select: text;
  }
  progress {
    width: 100%;
    height: 1.2rem;
    margin: 0.5rem 0 1rem 0;
    border-radius: 5px;
    background: #222;
  }
  a {
    margin-top: 0.6rem;
    color: #4af;
    word-break: break-word;
  }
</style>
</head>
<body>

<h1>Giga Encrytor Its Great</h1>

<h2>Encrypt</h2>
<input type="file" id="fileInput" multiple />
<input type="password" id="encryptPassword" placeholder="Enter or generate password" autocomplete="new-password" />
<button id="genPassBtn">Generate 50-Char Strong Password</button>
<div id="passwordDisplay"></div>
<button id="encryptBtn">Encrypt Files (100 Layers)</button>
<progress id="encryptProgress" max="100" value="0" style="display:none;"></progress>
<div id="encryptOutput"></div>

<hr />

<h2>Decrypt</h2>
<input type="file" id="decryptFileInput" multiple />
<input type="password" id="decryptPassword" placeholder="Enter password to decrypt" autocomplete="off" />
<button id="decryptBtn">Decrypt Files</button>
<progress id="decryptProgress" max="100" value="0" style="display:none;"></progress>
<div id="decryptOutput"></div>

<script>
const SALT_LENGTH = 32;
const IV_LENGTH = 12;
const LAYERS = 100;
const DECOY_COUNT = 20;
const DECOY_SIZE_MIN = 128; // bytes
const DECOY_SIZE_MAX = 512; // bytes

function getRandomChar() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+[]{}|;:,.<>?~';
  return chars.charAt(Math.floor(Math.random() * chars.length));
}
function generatePassword(length = 50) {
  let pass = '';
  while (pass.length < length) {
    pass += getRandomChar();
  }
  return pass;
}
function encodeUTF8(str) { return new TextEncoder().encode(str); }
function decodeUTF8(buf) { return new TextDecoder().decode(buf); }
async function getRandomBytes(len) {
  const arr = new Uint8Array(len);
  crypto.getRandomValues(arr);
  return arr;
}
async function deriveKey(password, salt) {
  const pwUtf8 = encodeUTF8(password);
  const baseKey = await crypto.subtle.importKey('raw', pwUtf8, 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 1000000, hash: 'SHA-256' },
    baseKey,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
}
async function encryptLayer(buffer, password) {
  const salt = await getRandomBytes(SALT_LENGTH);
  const iv = await getRandomBytes(IV_LENGTH);
  const key = await deriveKey(password, salt);
  const encrypted = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, buffer);
  const combined = new Uint8Array(SALT_LENGTH + IV_LENGTH + encrypted.byteLength);
  combined.set(salt, 0);
  combined.set(iv, SALT_LENGTH);
  combined.set(new Uint8Array(encrypted), SALT_LENGTH + IV_LENGTH);
  return combined.buffer;
}
async function decryptLayer(buffer, password) {
  const data = new Uint8Array(buffer);
  const salt = data.slice(0, SALT_LENGTH);
  const iv = data.slice(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);
  const ciphertext = data.slice(SALT_LENGTH + IV_LENGTH);
  const key = await deriveKey(password, salt.buffer);
  const decrypted = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ciphertext.buffer);
  return decrypted;
}
async function generateDecoys() {
  const decoys = [];
  for(let i=0; i<DECOY_COUNT; i++) {
    const size = DECOY_SIZE_MIN + Math.floor(Math.random()*(DECOY_SIZE_MAX-DECOY_SIZE_MIN));
    const arr = await getRandomBytes(size);
    decoys.push(arr);
  }
  return decoys;
}
async function addFakeHeadersAndDecoys(buffer) {
  const pngHeader = new Uint8Array([0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A]);
  const pdfHeader = new TextEncoder().encode('%PDF-1.7\n%����\n');
  const zipHeader = new Uint8Array([0x50,0x4B,0x03,0x04]);
  const fakeHeaders = [pngHeader, pdfHeader, zipHeader];
  const decoys = await generateDecoys();
  let totalSize = buffer.byteLength;
  fakeHeaders.forEach(h => totalSize += h.byteLength);
  decoys.forEach(d => totalSize += d.byteLength);
  const combined = new Uint8Array(totalSize);
  let offset = 0;
  for(const header of fakeHeaders) {
    combined.set(header, offset);
    offset += header.byteLength;
  }
  combined.set(new Uint8Array(buffer), offset);
  offset += buffer.byteLength;
  for(const decoy of decoys) {
    combined.set(decoy, offset);
    offset += decoy.byteLength;
  }
  return combined.buffer;
}
async function encryptMultiLayer(buffer, password, onProgress) {
  let data = await addFakeHeadersAndDecoys(buffer);
  for(let i=0; i<LAYERS; i++) {
    data = await encryptLayer(data, password);
    if(onProgress) onProgress(i+1);
    await new Promise(r=>setTimeout(r,1)); // yield for UI
  }
  return data;
}
async function decryptMultiLayer(buffer, password, onProgress) {
  let data = buffer;
  for(let i=0; i<LAYERS; i++) {
    data = await decryptLayer(data, password);
    if(onProgress) onProgress(i+1);
    await new Promise(r=>setTimeout(r,1));
  }
  // Strip fake headers and decoys - best effort by removing first bytes matching known headers and trailing decoys sizes unknown
  // For simplicity, just return raw decrypted data here
  return data;
}
function saveFile(buffer, name) {
  const blob = new Blob([buffer]);
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
function createLog(msg) {
  const d = document.createElement('div');
  d.textContent = msg;
  return d;
}

const fileInput = document.getElementById('fileInput');
const encryptPassword = document.getElementById('encryptPassword');
const genPassBtn = document.getElementById('genPassBtn');
const encryptBtn = document.getElementById('encryptBtn');
const encryptProgress = document.getElementById('encryptProgress');
const encryptOutput = document.getElementById('encryptOutput');
const passwordDisplay = document.getElementById('passwordDisplay');

const decryptFileInput = document.getElementById('decryptFileInput');
const decryptPassword = document.getElementById('decryptPassword');
const decryptBtn = document.getElementById('decryptBtn');
const decryptProgress = document.getElementById('decryptProgress');
const decryptOutput = document.getElementById('decryptOutput');

genPassBtn.onclick = () => {
  const p = generatePassword();
  encryptPassword.value = p;
  passwordDisplay.textContent = p;
};
encryptBtn.onclick = async () => {
  if (!fileInput.files.length) {
    alert('Select files');
    return;
  }
  if (!encryptPassword.value) {
    alert('Enter or generate password');
    return;
  }
  encryptBtn.disabled = true; genPassBtn.disabled = true;
  encryptProgress.style.display = 'block';
  encryptProgress.value = 0;
  encryptOutput.innerHTML = '';
  try {
    for(let f of fileInput.files) {
      encryptOutput.appendChild(createLog(`Encrypting: ${f.name}`));
      const buffer = await f.arrayBuffer();
      const encrypted = await encryptMultiLayer(buffer, encryptPassword.value, v => {
        encryptProgress.value = (v / LAYERS) * 100;
      });
      saveFile(encrypted, f.name + '.SuperEncrypted');
      encryptOutput.appendChild(createLog(`Encrypted saved: ${f.name}.SuperEncrypted`));
    }
  } catch(e) {
    alert('Encryption failed: ' + e.message);
  }
  encryptBtn.disabled = false; genPassBtn.disabled = false;
  encryptProgress.style.display = 'none';
};
decryptBtn.onclick = async () => {
  if (!decryptFileInput.files.length) {
    alert('Select encrypted files');
    return;
  }
  if (!decryptPassword.value) {
    alert('Enter password');
    return;
  }
  decryptBtn.disabled = true;
  decryptProgress.style.display = 'block';
  decryptProgress.value = 0;
  decryptOutput.innerHTML = '';
  try {
    for(let f of decryptFileInput.files) {
      decryptOutput.appendChild(createLog(`Decrypting: ${f.name}`));
      const buffer = await f.arrayBuffer();
      const decrypted = await decryptMultiLayer(buffer, decryptPassword.value, v => {
        decryptProgress.value = (v / LAYERS) * 100;
      });
      const originalName = f.name.replace(/\.SuperEncrypted$/, '') || 'decrypted.file';
      saveFile(decrypted, originalName);
      decryptOutput.appendChild(createLog(`Decrypted saved: ${originalName}`));
    }
  } catch(e) {
    alert('Decryption failed: ' + e.message);
  }
  decryptBtn.disabled = false;
  decryptProgress.style.display = 'none';
};
</script>

</body>
</html>
